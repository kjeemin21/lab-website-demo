<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" as="style" crossorigin href="https://cdn.jsdelivr.net/gh/orioncactus/pretendard@v1.3.9/dist/web/static/pretendard.min.css" />
    <link rel="stylesheet" href="{{ "/assets/css/style.css" | relative_url }}">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/cytoscape@3.28.1/dist/cytoscape.min.js"></script>
    <title>{{ page.title }} | {{ site.title }}</title>
</head>
<body>
    <header class="site-header">
        <div class="header-container">
            <h1 class="site-title">
                <a href="{{ "/" | relative_url }}">
                    <img src="{{ '/assets/images/icons/logo_bdi_v3.svg' | relative_url }}" alt="{{ site.title }}" class="site-logo">
                    <span class="site-title-text">{{ site.title }}</span>
                </a>
            </h1>
            <nav class="main-nav">
                <button class="tab-button active" data-tab="about">About</button>
                <button class="tab-button" data-tab="professor">Professor</button>
                <button class="tab-button" data-tab="members">Members</button>
                <button class="tab-button" data-tab="publications">Publications</button>
                <button class="tab-button" data-tab="projects">Projects</button>
                <button class="tab-button" data-tab="photos">Photos</button>
                <button class="tab-button" data-tab="recruit">Recruit</button>
            </nav>
            <button class="menu-toggle" aria-label="Toggle menu">
                <img src="{{ '/assets/images/icons/menu_icon.svg' | relative_url }}" alt="Menu" class="menu-icon">
            </button>
        </div>
    </header>

    <!-- Side Menu Overlay -->
    <div class="side-menu-overlay"></div>
    
    <!-- Side Menu -->
    <nav class="side-menu">
        <div class="side-menu-header">
            <button class="menu-close" aria-label="Close menu">
                <span>&times;</span>
            </button>
        </div>
        <ul class="side-menu-list">
            <li><button class="side-menu-tab" data-tab="about">About</button></li>
            <li><button class="side-menu-tab" data-tab="professor">Professor</button></li>
            <li><button class="side-menu-tab" data-tab="members">Members</button></li>
            <li><button class="side-menu-tab" data-tab="publications">Publications</button></li>
            <li><button class="side-menu-tab" data-tab="projects">Projects</button></li>
            <li><button class="side-menu-tab" data-tab="photos">Photos</button></li>
            <li><button class="side-menu-tab" data-tab="recruit">Recruit</button></li>
        </ul>
    </nav>

    <main>
        {{ content }}
    </main>

    <footer class="site-footer">
        <div class="footer-container">
            <p>&copy; {{ site.time | date: "%Y" }} {{ site.title }}. All rights reserved.</p>
            {% if site.github_username %}
            <p>
                <a href="https://github.com/{{ site.github_username }}" target="_blank" rel="noopener">GitHub</a>
            </p>
            {% endif %}
        </div>
    </footer>

    <script>
        // Disable browser's automatic scroll restoration
        if ('scrollRestoration' in history) {
            history.scrollRestoration = 'manual';
        }
        
        // Force scroll to top immediately on script execution
        window.scrollTo(0, 0);
        
        // Menu toggle functionality
        const menuToggle = document.querySelector('.menu-toggle');
        const menuClose = document.querySelector('.menu-close');
        const sideMenu = document.querySelector('.side-menu');
        const sideMenuOverlay = document.querySelector('.side-menu-overlay');

        function openSideMenu() {
            sideMenu.classList.add('active');
            sideMenuOverlay.classList.add('active');
            document.body.style.overflow = 'hidden';
        }

        function closeSideMenu() {
            sideMenu.classList.remove('active');
            sideMenuOverlay.classList.remove('active');
            document.body.style.overflow = '';
        }

        if (menuToggle) {
            menuToggle.addEventListener('click', openSideMenu);
        }

        if (menuClose) {
            menuClose.addEventListener('click', closeSideMenu);
        }

        if (sideMenuOverlay) {
            sideMenuOverlay.addEventListener('click', closeSideMenu);
        }

        // Tab switching functionality
        function switchTab(tabId) {
            // Remove active class from all tab buttons
            document.querySelectorAll('.tab-button').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // Remove active class from all side menu tabs
            document.querySelectorAll('.side-menu-tab').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // Hide all tab panels
            document.querySelectorAll('.tab-panel').forEach(panel => {
                panel.classList.remove('active');
            });
            
            // Show selected tab panel
            const targetPanel = document.querySelector(`#${tabId}.tab-panel`);
            if (targetPanel) {
                targetPanel.classList.add('active');
            }
            
            // Activate corresponding tab button
            const targetTabButton = document.querySelector(`.tab-button[data-tab="${tabId}"]`);
            if (targetTabButton) {
                targetTabButton.classList.add('active');
            }
            
            // Activate corresponding side menu tab
            const targetSideMenuTab = document.querySelector(`.side-menu-tab[data-tab="${tabId}"]`);
            if (targetSideMenuTab) {
                targetSideMenuTab.classList.add('active');
            }
            
            // Update URL hash
            if (history.pushState) {
                history.pushState(null, null, `#${tabId}`);
            } else {
                window.location.hash = `#${tabId}`;
            }
            
            // Scroll to top of main content
            window.scrollTo(0, 0);
            
            // For About tab, ensure scroll stays at top
            if (tabId === 'about') {
                setTimeout(function() {
                    window.scrollTo(0, 0);
                }, 50);
            }
            
            // Initialize publications menu if publications tab is active
            if (tabId === 'publications') {
                setTimeout(function() {
                    initPublicationsMenuWithClose();
                    initPublicationsShowMore();
                }, 100);
            }
            
            // Initialize members menu if members tab is active
            if (tabId === 'members') {
                setTimeout(initMembersMenuWithClose, 100);
            }
            
            // Initialize photo items if photos tab is active
            if (tabId === 'photos') {
                setTimeout(function() {
                    if (typeof initBalancedPhotoGrid === 'function') {
                        initBalancedPhotoGrid();
                    }
                }, 100);
            }
            
            // Initialize about animations if about tab is active
            if (tabId === 'about') {
                setTimeout(function() {
                    initAboutAnimations();
                    initKnowledgeGraph();
                }, 100);
            }
        }

        // Tab button click handlers
        document.querySelectorAll('.tab-button').forEach(button => {
            button.addEventListener('click', function() {
                const tabId = this.getAttribute('data-tab');
                switchTab(tabId);
            });
        });

        // Side menu tab click handlers
        document.querySelectorAll('.side-menu-tab').forEach(button => {
            button.addEventListener('click', function() {
                const tabId = this.getAttribute('data-tab');
                switchTab(tabId);
                closeSideMenu();
            });
        });

        // Handle initial hash on page load
        function handleInitialHash() {
            const hash = window.location.hash.substring(1);
            if (hash) {
                const targetPanel = document.querySelector(`#${hash}.tab-panel`);
                if (targetPanel) {
                    switchTab(hash);
                    return;
                }
            }
            // Default to first tab if no valid hash
            switchTab('about');
            // Ensure scroll is at top for About tab
            window.scrollTo(0, 0);
        }

        // Initialize on page load
        handleInitialHash();
        
        // Also ensure scroll is at top after page fully loads
        window.addEventListener('load', function() {
            const hash = window.location.hash.substring(1);
            if (!hash || hash === 'about') {
                window.scrollTo(0, 0);
            }
        });

        // Handle window resize to maintain scroll position at top for About tab
        let resizeTimeout;
        let lastScrollY = window.scrollY;
        window.addEventListener('resize', function() {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(function() {
                const hash = window.location.hash.substring(1);
                const activeTab = document.querySelector('.tab-panel.active');
                if ((!hash || hash === 'about') && activeTab && activeTab.id === 'about') {
                    // If user was at or near the top before resize, keep them at top
                    // This prevents layout shifts from moving scroll position
                    if (lastScrollY < 50) {
                        window.scrollTo(0, 0);
                    }
                }
                lastScrollY = window.scrollY;
            }, 150);
        });
        
        // Track scroll position to detect if user intentionally scrolled
        window.addEventListener('scroll', function() {
            lastScrollY = window.scrollY;
        });

        // Handle browser back/forward buttons
        window.addEventListener('popstate', function() {
            handleInitialHash();
        });

        // Scroll blocking state
        let isScrolling = false;
        let scrollBlockTimeout = null;
        
        // Block user scroll during animation
        function blockUserScroll(event) {
            if (isScrolling) {
                event.preventDefault();
                event.stopPropagation();
                return false;
            }
        }
        
        function enableScrollBlock() {
            if (isScrolling) return;
            
            isScrolling = true;
            document.body.style.pointerEvents = 'none';
            
            // Block wheel events
            window.addEventListener('wheel', blockUserScroll, { passive: false, capture: true });
            window.addEventListener('touchmove', blockUserScroll, { passive: false, capture: true });
            
            // Block keyboard scroll
            window.addEventListener('keydown', blockUserScroll, { passive: false, capture: true });
        }
        
        function disableScrollBlock() {
            isScrolling = false;
            document.body.style.pointerEvents = '';
            
            // Unblock events
            window.removeEventListener('wheel', blockUserScroll, { capture: true });
            window.removeEventListener('touchmove', blockUserScroll, { capture: true });
            window.removeEventListener('keydown', blockUserScroll, { capture: true });
        }
        
        // Publications scroll functionality
        function scrollToPublicationSection(sectionId) {
            const targetSection = document.getElementById(sectionId);
            if (targetSection) {
                enableScrollBlock();
                
                const headerHeight = document.querySelector('.site-header')?.offsetHeight || 100;
                const offsetTop = targetSection.offsetTop - headerHeight - 20;
                const startPosition = window.scrollY;
                const distance = offsetTop - startPosition;
                const duration = 400; // 400ms for smooth and fast animation
                let startTime = null;
                
                function animation(currentTime) {
                    if (startTime === null) startTime = currentTime;
                    const timeElapsed = currentTime - startTime;
                    const progress = Math.min(timeElapsed / duration, 1);
                    
                    // Easing function (ease-in-out)
                    const ease = progress < 0.5 
                        ? 2 * progress * progress 
                        : 1 - Math.pow(-2 * progress + 2, 2) / 2;
                    
                    window.scrollTo(0, startPosition + distance * ease);
                    
                    if (timeElapsed < duration) {
                        requestAnimationFrame(animation);
                    } else {
                        // Animation complete
                        clearTimeout(scrollBlockTimeout);
                        scrollBlockTimeout = setTimeout(disableScrollBlock, 50);
                    }
                }
                
                requestAnimationFrame(animation);
            }
        }

        // Publications menu toggle functionality (for mobile)
        const publicationsMenuToggle = document.querySelector('.publications-menu-toggle');
        const publicationsMenuClose = document.querySelector('.publications-menu-close');
        const publicationsSideMenu = document.querySelector('.publications-side-menu');
        const publicationsMenuOverlay = document.querySelector('.publications-menu-overlay');

        function openPublicationsMenu() {
            if (publicationsSideMenu) {
                publicationsSideMenu.classList.add('active');
            }
            if (publicationsMenuOverlay) {
                publicationsMenuOverlay.classList.add('active');
            }
            if (document.body) {
                document.body.style.overflow = 'hidden';
            }
        }

        function closePublicationsMenu() {
            if (publicationsSideMenu) {
                publicationsSideMenu.classList.remove('active');
            }
            if (publicationsMenuOverlay) {
                publicationsMenuOverlay.classList.remove('active');
            }
            if (document.body) {
                document.body.style.overflow = '';
            }
        }

        if (publicationsMenuToggle) {
            publicationsMenuToggle.addEventListener('click', openPublicationsMenu);
        }

        if (publicationsMenuClose) {
            publicationsMenuClose.addEventListener('click', closePublicationsMenu);
        }

        if (publicationsMenuOverlay) {
            publicationsMenuOverlay.addEventListener('click', closePublicationsMenu);
        }

        // Scroll to section when clicking on a menu button
        function initPublicationsMenuWithClose() {
            const menuButtons = document.querySelectorAll('.publication-menu-btn');

            menuButtons.forEach(button => {
                if (!button.hasAttribute('data-initialized')) {
                    button.setAttribute('data-initialized', 'true');
                    button.addEventListener('click', function() {
                        const sectionId = this.getAttribute('data-scroll');
                        if (sectionId) {
                            scrollToPublicationSection(sectionId);
                            
                            // Update active button
                            menuButtons.forEach(btn => btn.classList.remove('active'));
                            this.classList.add('active');
                            
                            // Close menu on mobile after selection
                            if (window.innerWidth <= 620) {
                                closePublicationsMenu();
                            }
                        }
                    });
                }
            });
            
            // Update active button based on scroll position
            function updateActivePublicationButton() {
                const sections = ['publications-international', 'publications-domestic', 'publications-patents'];
                const headerHeight = document.querySelector('.site-header')?.offsetHeight || 100;
                const scrollPosition = window.scrollY + headerHeight + 50;
                
                let activeSection = null;
                sections.forEach(sectionId => {
                    const section = document.getElementById(sectionId);
                    if (section && scrollPosition >= section.offsetTop) {
                        activeSection = sectionId;
                    }
                });
                
                if (activeSection) {
                    menuButtons.forEach(btn => {
                        if (btn.getAttribute('data-scroll') === activeSection) {
                            btn.classList.add('active');
                        } else {
                            btn.classList.remove('active');
                        }
                    });
                }
            }
            
            // Update on scroll
            let scrollTimeout;
            window.addEventListener('scroll', function() {
                clearTimeout(scrollTimeout);
                scrollTimeout = setTimeout(updateActivePublicationButton, 100);
            });
            
            // Initial update
            updateActivePublicationButton();
        }

        // Publications Show More functionality
        function initPublicationsShowMore() {
            const containers = document.querySelectorAll('.publications-show-more-container');
            
            containers.forEach(container => {
                const showMoreBtn = container.querySelector('.publications-show-more-btn');
                const showLessBtn = container.querySelector('.publications-show-less-btn');
                
                if (!showMoreBtn || !showLessBtn) return;
                if (showMoreBtn.hasAttribute('data-initialized')) return;
                
                showMoreBtn.setAttribute('data-initialized', 'true');
                showLessBtn.setAttribute('data-initialized', 'true');
                
                const sectionId = showMoreBtn.getAttribute('data-section');
                const initialLimit = parseInt(showMoreBtn.getAttribute('data-limit')) || 10;
                const section = document.getElementById(sectionId);
                
                if (!section) return;
                
                const allItems = section.querySelectorAll('.publication-item');
                const totalItems = allItems.length;
                let currentVisible = initialLimit;
                
                // Show More button handler
                showMoreBtn.addEventListener('click', function() {
                    currentVisible = Math.min(currentVisible + 10, totalItems);
                    
                    allItems.forEach((item, index) => {
                        if (index < currentVisible) {
                            item.classList.remove('publication-item-hidden');
                        }
                    });
                    
                    // Update button visibility
                    if (currentVisible >= totalItems) {
                        showMoreBtn.style.display = 'none';
                    }
                    if (currentVisible > initialLimit) {
                        showLessBtn.style.display = 'inline-flex';
                    }
                });
                
                // Show Less button handler
                showLessBtn.addEventListener('click', function() {
                    currentVisible = Math.max(currentVisible - 10, initialLimit);
                    
                    allItems.forEach((item, index) => {
                        if (index >= currentVisible) {
                            item.classList.add('publication-item-hidden');
                        }
                    });
                    
                    // Update button visibility
                    if (currentVisible < totalItems) {
                        showMoreBtn.style.display = 'inline-flex';
                    }
                    if (currentVisible <= initialLimit) {
                        showLessBtn.style.display = 'none';
                    }
                });
            });
        }

        // Members scroll functionality
        function scrollToMemberSection(sectionId) {
            const targetSection = document.getElementById(sectionId);
            if (targetSection) {
                enableScrollBlock();
                
                const headerHeight = document.querySelector('.site-header')?.offsetHeight || 100;
                const offsetTop = targetSection.offsetTop - headerHeight - 20;
                const startPosition = window.scrollY;
                const distance = offsetTop - startPosition;
                const duration = 400; // 400ms for smooth and fast animation
                let startTime = null;
                
                function animation(currentTime) {
                    if (startTime === null) startTime = currentTime;
                    const timeElapsed = currentTime - startTime;
                    const progress = Math.min(timeElapsed / duration, 1);
                    
                    // Easing function (ease-in-out)
                    const ease = progress < 0.5 
                        ? 2 * progress * progress 
                        : 1 - Math.pow(-2 * progress + 2, 2) / 2;
                    
                    window.scrollTo(0, startPosition + distance * ease);
                    
                    if (timeElapsed < duration) {
                        requestAnimationFrame(animation);
                    } else {
                        // Animation complete
                        clearTimeout(scrollBlockTimeout);
                        scrollBlockTimeout = setTimeout(disableScrollBlock, 50);
                    }
                }
                
                requestAnimationFrame(animation);
            }
        }

        // Members menu toggle functionality (for mobile)
        const membersMenuToggle = document.querySelector('.members-menu-toggle');
        const membersMenuClose = document.querySelector('.members-menu-close');
        const membersSideMenu = document.querySelector('.members-side-menu');
        const membersMenuOverlay = document.querySelector('.members-menu-overlay');

        function openMembersMenu() {
            if (membersSideMenu) {
                membersSideMenu.classList.add('active');
            }
            if (membersMenuOverlay) {
                membersMenuOverlay.classList.add('active');
            }
            if (document.body) {
                document.body.style.overflow = 'hidden';
            }
        }

        function closeMembersMenu() {
            if (membersSideMenu) {
                membersSideMenu.classList.remove('active');
            }
            if (membersMenuOverlay) {
                membersMenuOverlay.classList.remove('active');
            }
            if (document.body) {
                document.body.style.overflow = '';
            }
        }

        if (membersMenuToggle) {
            membersMenuToggle.addEventListener('click', openMembersMenu);
        }

        if (membersMenuClose) {
            membersMenuClose.addEventListener('click', closeMembersMenu);
        }

        if (membersMenuOverlay) {
            membersMenuOverlay.addEventListener('click', closeMembersMenu);
        }

        // Scroll to section when clicking on a menu button
        function initMembersMenuWithClose() {
            const menuButtons = document.querySelectorAll('.member-menu-btn');

            menuButtons.forEach(button => {
                if (!button.hasAttribute('data-initialized')) {
                    button.setAttribute('data-initialized', 'true');
                    button.addEventListener('click', function() {
                        const sectionId = this.getAttribute('data-scroll');
                        if (sectionId) {
                            scrollToMemberSection(sectionId);
                            
                            // Update active button
                            menuButtons.forEach(btn => btn.classList.remove('active'));
                            this.classList.add('active');
                            
                            // Close menu on mobile after selection
                            if (window.innerWidth <= 620) {
                                closeMembersMenu();
                            }
                        }
                    });
                }
            });
            
            // Update active button based on scroll position
            function updateActiveMemberButton() {
                const sections = ['members-phd', 'members-ms', 'members-alumni'];
                const headerHeight = document.querySelector('.site-header')?.offsetHeight || 100;
                const scrollPosition = window.scrollY + headerHeight + 50;
                
                let activeSection = null;
                sections.forEach(sectionId => {
                    const section = document.getElementById(sectionId);
                    if (section && scrollPosition >= section.offsetTop) {
                        activeSection = sectionId;
                    }
                });
                
                if (activeSection) {
                    menuButtons.forEach(btn => {
                        if (btn.getAttribute('data-scroll') === activeSection) {
                            btn.classList.add('active');
                        } else {
                            btn.classList.remove('active');
                        }
                    });
                }
            }
            
            // Update on scroll
            let scrollTimeout;
            window.addEventListener('scroll', function() {
                clearTimeout(scrollTimeout);
                scrollTimeout = setTimeout(updateActiveMemberButton, 100);
            });
            
            // Initial update
            updateActiveMemberButton();
        }

        // About section scroll-based animations
        function initAboutAnimations() {
            // Force scroll to top when initializing About animations
            window.scrollTo(0, 0);
        }

        // Also initialize on page load if publications or members tab is active
        document.addEventListener('DOMContentLoaded', function() {
            const hash = window.location.hash.substring(1);
            
            // Force scroll to top for About tab or no hash
            if (!hash || hash === 'about') {
                window.scrollTo(0, 0);
            }
            
            if (hash === 'publications' || (!hash && document.querySelector('#publications.tab-panel.active'))) {
                setTimeout(function() {
                    initPublicationsMenuWithClose();
                    initPublicationsShowMore();
                }, 100);
            }
            if (hash === 'members' || (!hash && document.querySelector('#members.tab-panel.active'))) {
                setTimeout(initMembersMenuWithClose, 100);
            }
            if (hash === 'about' || (!hash && document.querySelector('#about.tab-panel.active'))) {
                setTimeout(function() {
                    initAboutAnimations();
                    initKnowledgeGraph();
                    // Double-check scroll position after animations init
                    setTimeout(function() {
                        window.scrollTo(0, 0);
                    }, 50);
                }, 100);
            }
        });

        // Balanced Photo Grid functionality with lazy loading
        function initBalancedPhotoGrid() {
            const photosDataElement = document.getElementById('photos-data');
            if (!photosDataElement) return;
            
            try {
                const photosData = JSON.parse(photosDataElement.textContent);
                
                // 1. Sort by date (most recent first)
                photosData.sort((a, b) => {
                    const dateA = new Date(a.date || '1970-01-01');
                    const dateB = new Date(b.date || '1970-01-01');
                    return dateB - dateA;
                });
                
                // 2. Determine number of columns based on screen width
                const screenWidth = window.innerWidth;
                let numColumns = 3;
                if (screenWidth <= 480) {
                    numColumns = 1;
                } else if (screenWidth <= 768) {
                    numColumns = 2;
                }
                
                const columns = Array.from({ length: numColumns }, () => []);
                const columnHeights = Array(numColumns).fill(0);
                
                // 3. Calculate column width (approximate)
                const gridContainer = document.getElementById('photosGrid');
                if (!gridContainer) return;
                
                const containerWidth = gridContainer.offsetWidth || 1200;
                const gap = (screenWidth <= 768) ? 15 : 20;
                const columnWidth = (containerWidth - (gap * (numColumns - 1))) / numColumns;
                
                // Use estimated aspect ratio for distribution (most photos are 3:4 or 4:3)
                const estimatedAspectRatio = 1.0; // Square-ish average
                const estimatedHeight = columnWidth * estimatedAspectRatio;
                
                // 4. Distribute photos to shortest column
                photosData.forEach(photo => {
                    const shortestColumnIndex = columnHeights.indexOf(Math.min(...columnHeights));
                    columns[shortestColumnIndex].push(photo);
                    columnHeights[shortestColumnIndex] += estimatedHeight + gap;
                });
                
                // 5. Render columns to DOM with lazy loading
                renderPhotoColumns(columns);
                
            } catch (error) {
                console.error('Error loading photos:', error);
            }
        }
        
        function renderPhotoColumns(columns) {
            const gridContainer = document.getElementById('photosGrid');
            if (!gridContainer) return;
            
            // Clear existing content
            gridContainer.innerHTML = '';
            
            // Create columns
            columns.forEach((columnPhotos, columnIndex) => {
                const columnDiv = document.createElement('div');
                columnDiv.className = 'photo-column';
                
                columnPhotos.forEach(photo => {
                    const photoItem = document.createElement('div');
                    photoItem.className = 'photo-item';
                    photoItem.setAttribute('data-image', photo.image);
                    
                    const img = document.createElement('img');
                    img.src = photo.image;
                    img.alt = photo.caption || 'Lab photo';
                    img.loading = 'lazy'; // Native browser lazy loading
                    
                    photoItem.appendChild(img);
                    columnDiv.appendChild(photoItem);
                });
                
                gridContainer.appendChild(columnDiv);
            });
            
            // Re-initialize photo items for lightbox
            initPhotoItems();
        }

        // Photo Lightbox functionality
        const photoLightbox = document.getElementById('photoLightbox');
        const lightboxImage = document.getElementById('lightboxImage');
        const lightboxClose = document.querySelector('.photo-lightbox-close');
        let photoItems = document.querySelectorAll('.photo-item');

        function openPhotoLightbox(imageSrc, clickedImg) {
            if (!lightboxImage || !photoLightbox) return;
            
            // Set image source
            lightboxImage.src = imageSrc;
            
            // Show lightbox with fade-in and scale effect
            photoLightbox.style.visibility = 'visible';
            photoLightbox.classList.add('active');
            document.body.style.overflow = 'hidden';
        }

        function closePhotoLightbox() {
            if (!photoLightbox) return;

            // Add closing class for fade-out effect
            photoLightbox.classList.add('closing');
            photoLightbox.classList.remove('active');
            
            // Wait for animation to complete before hiding
            setTimeout(() => {
                photoLightbox.classList.remove('closing');
                photoLightbox.style.visibility = 'hidden';
                document.body.style.overflow = '';
            }, 300);
        }

        // Add click handlers to photo items
        function initPhotoItems() {
            photoItems = document.querySelectorAll('.photo-item');
            photoItems.forEach(item => {
                item.addEventListener('click', function(e) {
                    const img = this.querySelector('img');
                    if (img) {
                        const imageSrc = this.getAttribute('data-image') || img.src;
                        if (imageSrc) {
                            openPhotoLightbox(imageSrc, img);
                        }
                    }
                });
            });
        }

        // Initialize photo items
        initPhotoItems();

        // Re-initialize when photos tab is opened
        const originalSwitchTab = window.switchTab;
        if (typeof switchTab === 'function') {
            // This will be handled by the existing switchTab function
        }

        // Also initialize on DOMContentLoaded
        document.addEventListener('DOMContentLoaded', function() {
            const hash = window.location.hash.substring(1);
            if (hash === 'photos') {
                setTimeout(initBalancedPhotoGrid, 100);
            }
        });
        
        // Re-balance grid on window resize
        let resizePhotoTimeout;
        window.addEventListener('resize', function() {
            clearTimeout(resizePhotoTimeout);
            resizePhotoTimeout = setTimeout(function() {
                const photosTab = document.querySelector('#photos.tab-panel');
                if (photosTab && photosTab.classList.contains('active')) {
                    initBalancedPhotoGrid();
                }
            }, 300);
        });

        // Close lightbox handlers
        if (lightboxClose) {
            lightboxClose.addEventListener('click', closePhotoLightbox);
        }

        if (photoLightbox) {
            photoLightbox.addEventListener('click', function(e) {
                if (e.target === photoLightbox) {
                    closePhotoLightbox();
                }
            });
        }

        // Close on Escape key
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape' && photoLightbox && photoLightbox.classList.contains('active')) {
                closePhotoLightbox();
            }
        });

        // Knowledge Graph Initialization
        let cyInstance = null; // 전역 인스턴스 저장
        
        function initKnowledgeGraph() {
            // 이미 초기화되었으면 리턴
            if (cyInstance) {
                console.log('Knowledge Graph already initialized');
                return;
            }
            
            const graphDataElement = document.getElementById('graph-data');
            if (!graphDataElement) {
                console.warn('Graph data element not found');
                return;
            }
            
            const cyContainer = document.getElementById('cy');
            if (!cyContainer) {
                console.warn('Cytoscape container not found');
                return;
            }
            
            if (!window.cytoscape) {
                console.warn('Cytoscape library not loaded');
                return;
            }
            
            // 컨테이너가 렌더링될 때까지 대기
            if (cyContainer.offsetWidth === 0 || cyContainer.offsetHeight === 0) {
                console.warn('Container not visible, retrying in 100ms...');
                setTimeout(initKnowledgeGraph, 100);
                return;
            }
            
            try {
                const graphData = JSON.parse(graphDataElement.textContent);
                
                // 장식 노드 생성 함수
                function generateDecoratorNodes(mainNodes) {
                    const decoratorNodes = [];
                    const decoratorEdges = [];
                    const allDecorators = [];
                    const connectionCount = {}; // 각 decorator의 연결 수 추적
                    
                    mainNodes.forEach((mainNode) => {
                        const numDecorators = 5 + Math.floor(Math.random() * 4); // 5-8개
                        const baseColor = mainNode.color;
                        const zoneDecorators = [];
                        
                        for (let i = 0; i < numDecorators; i++) {
                            const decoratorId = `decorator-${mainNode.id}-${i}`;
                            const size = 25 + Math.floor(Math.random() * 20); // 25-44px 가변 크기
                            
                            // 장식 노드 추가
                            decoratorNodes.push({
                                data: {
                                    id: decoratorId,
                                    parentZone: mainNode.id,
                                    color: baseColor,
                                    isDecorator: true,
                                    size: size
                                }
                            });
                            
                            zoneDecorators.push(decoratorId);
                            allDecorators.push(decoratorId);
                            connectionCount[decoratorId] = 0;
                            
                            // 메인 노드와 연결
                            decoratorEdges.push({
                                data: {
                                    id: `edge-${mainNode.id}-${decoratorId}`,
                                    source: mainNode.id,
                                    target: decoratorId
                                }
                            });
                            connectionCount[decoratorId]++;
                            
                            // 같은 구역 내 장식 노드끼리 연결 (50% 확률)
                            if (i > 0 && Math.random() < 0.5) {
                                const targetDecorator = zoneDecorators[Math.floor(Math.random() * i)];
                                decoratorEdges.push({
                                    data: {
                                        id: `edge-${decoratorId}-${targetDecorator}`,
                                        source: decoratorId,
                                        target: targetDecorator
                                    }
                                });
                                connectionCount[decoratorId]++;
                                connectionCount[targetDecorator]++;
                            }
                            
                            // 다른 메인 노드와도 연결 (30% 확률)
                            if (Math.random() < 0.3) {
                                const otherMainNodes = mainNodes.filter(node => node.id !== mainNode.id);
                                if (otherMainNodes.length > 0) {
                                    const randomMainNode = otherMainNodes[Math.floor(Math.random() * otherMainNodes.length)];
                                    decoratorEdges.push({
                                        data: {
                                            id: `edge-main-${randomMainNode.id}-${decoratorId}`,
                                            source: randomMainNode.id,
                                            target: decoratorId
                                        }
                                    });
                                    connectionCount[decoratorId]++;
                                }
                            }
                        }
                    });
                    
                    // 다른 구역 간 크로스 연결 추가 (20% 확률)
                    const numCrossConnections = Math.floor(allDecorators.length * 0.2);
                    for (let i = 0; i < numCrossConnections; i++) {
                        const source = allDecorators[Math.floor(Math.random() * allDecorators.length)];
                        const target = allDecorators[Math.floor(Math.random() * allDecorators.length)];
                        
                        if (source !== target) {
                            decoratorEdges.push({
                                data: {
                                    id: `edge-cross-${i}-${source}-${target}`,
                                    source: source,
                                    target: target
                                }
                            });
                            connectionCount[source]++;
                            connectionCount[target]++;
                        }
                    }
                    
                    // 최소 2개 연결 보장: 연결이 2개 미만인 decorator 찾아서 추가 연결
                    allDecorators.forEach(decoratorId => {
                        while (connectionCount[decoratorId] < 2) {
                            // 랜덤으로 다른 노드와 연결 (decorator 또는 main node)
                            const useMainNode = Math.random() < 0.4; // 40% 확률로 메인 노드와 연결
                            
                            if (useMainNode && mainNodes.length > 0) {
                                const randomMainNode = mainNodes[Math.floor(Math.random() * mainNodes.length)];
                                decoratorEdges.push({
                                    data: {
                                        id: `edge-min-main-${randomMainNode.id}-${decoratorId}`,
                                        source: randomMainNode.id,
                                        target: decoratorId
                                    }
                                });
                                connectionCount[decoratorId]++;
                            } else {
                                // 다른 decorator와 연결
                                const availableTargets = allDecorators.filter(id => id !== decoratorId);
                                if (availableTargets.length > 0) {
                                    const target = availableTargets[Math.floor(Math.random() * availableTargets.length)];
                                    decoratorEdges.push({
                                        data: {
                                            id: `edge-min-${decoratorId}-${target}`,
                                            source: decoratorId,
                                            target: target
                                        }
                                    });
                                    connectionCount[decoratorId]++;
                                    connectionCount[target]++;
                                } else {
                                    break; // 연결할 타겟이 없으면 종료
                                }
                            }
                        }
                    });
                    
                    return { decoratorNodes, decoratorEdges };
                }
                
                // Cytoscape 요소 준비
                const elements = [];
                
                // 메인 노드 추가
                graphData.nodes.forEach(node => {
                    elements.push({
                        data: {
                            id: node.id,
                            label: node.label,
                            description: node.description,
                            color: node.color,
                            isDecorator: false
                        },
                        classes: 'main-node' // 클래스 추가
                    });
                });
                
                // 장식 노드 생성 및 추가
                const { decoratorNodes, decoratorEdges } = generateDecoratorNodes(graphData.nodes);
                decoratorNodes.forEach(node => {
                    node.classes = 'decorator-node'; // 클래스 추가
                });
                elements.push(...decoratorNodes);
                
                // 메인 엣지 추가
                graphData.edges.forEach(edge => {
                    elements.push({
                        data: {
                            id: `${edge.source}-${edge.target}`,
                            source: edge.source,
                            target: edge.target
                        }
                    });
                });
                
                // 장식 엣지 추가
                elements.push(...decoratorEdges);
                
                // Cytoscape 초기화
                cyInstance = cytoscape({
                    container: cyContainer,
                    elements: elements,
                    style: [
                        {
                            selector: '.main-node', // 중요 노드 (클래스 기반)
                            style: {
                                'shape': 'ellipse',
                                'background-color': 'data(color)',
                                'label': 'data(label)',
                                'color': '#ffffff',
                                'text-valign': 'center',
                                'text-halign': 'center',
                                'font-size': '18px',
                                'font-weight': '700',
                                'font-family': 'Pretendard Variable, Pretendard, sans-serif',
                                'text-outline-width': '2px',
                                'text-outline-color': '#000000',
                                'text-outline-opacity': 0.3,
                                'width': '200px',
                                'height': '200px',
                                'text-wrap': 'wrap',
                                'text-max-width': '175px',
                                'border-width': '3px',
                                'border-color': '#ffffff',
                                'box-shadow': '0 4px 12px rgba(0, 0, 0, 0.15)',
                                'z-index': 10, // main nodes가 위에 오도록
                                'transition-property': 'background-color, border-color, box-shadow, width, height',
                                'transition-duration': '0.3s'
                            }
                        },
                        {
                            selector: '.decorator-node', // 작은 장식 노드 (클래스 기반)
                            style: {
                                'shape': 'ellipse',
                                'background-color': 'data(color)',
                                'width': 'data(size)',
                                'height': 'data(size)',
                                'border-width': '2px',
                                'border-color': '#ffffff',
                                'border-opacity': 0.7,
                                'background-opacity': 0.5,
                                'label': '',
                                'z-index': 1, // decorator nodes는 뒤에
                                'events': 'no'
                            }
                        },
                        {
                            selector: '.main-node:hover',
                            style: {
                                'width': '210px',
                                'height': '210px',
                                'box-shadow': '0 6px 20px rgba(0, 0, 0, 0.25)',
                                'cursor': 'pointer',
                                'border-width': '4px',
                                'z-index': 20 // 호버 시 더 위로
                            }
                        },
                        {
                            selector: 'edge',
                            style: {
                                'width': function(ele) {
                                    const sourceIsMain = ele.source().hasClass('main-node');
                                    const targetIsMain = ele.target().hasClass('main-node');
                                    return (sourceIsMain && targetIsMain) ? 3 : 1.5;
                                },
                                'line-color': function(ele) {
                                    const sourceColor = ele.source().data('color');
                                    const targetColor = ele.target().data('color');
                                    if (sourceColor === targetColor) {
                                        return sourceColor;
                                    }
                                    // 다른 색상 간 연결은 중간색 또는 회색
                                    return '#b0b0b0';
                                },
                                'opacity': function(ele) {
                                    const sourceIsMain = ele.source().hasClass('main-node');
                                    const targetIsMain = ele.target().hasClass('main-node');
                                    if (sourceIsMain && targetIsMain) return 0.6;
                                    
                                    // 크로스 구역 연결은 조금 더 투명하게
                                    const sourceColor = ele.source().data('color');
                                    const targetColor = ele.target().data('color');
                                    if (sourceColor !== targetColor) return 0.25;
                                    
                                    return 0.4;
                                },
                                'curve-style': 'bezier',
                                'z-index': 0 // edges는 모든 노드 아래
                            }
                        },
                        {
                            selector: '.highlighted',
                            style: {
                                'border-width': '5px',
                                'border-color': '#2c3e50',
                                'box-shadow': '0 8px 24px rgba(0, 0, 0, 0.3)',
                                'z-index': 100 // 하이라이트된 요소가 가장 위에
                            }
                        }
                    ],
                    layout: {
                        name: 'cose',
                        animate: true,
                        animationDuration: 1500,
                        fit: true,
                        padding: 10,
                        boundingBox: { 
                            x1: 0, 
                            y1: 0, 
                            w: cyContainer.offsetWidth * 1.6,
                            h: cyContainer.offsetHeight * 1.6
                        },
                        nodeRepulsion: function(node) {
                            // 노드 반발력을 대폭 증가하여 겹침 방지
                            return node.hasClass('decorator-node') ? 200000 : 2000000;
                        },
                        idealEdgeLength: function(edge) {
                            const sourceIsMain = edge.source().hasClass('main-node');
                            const targetIsMain = edge.target().hasClass('main-node');
                            // 메인 노드 간 거리를 늘려서 충분한 공간 확보
                            if (sourceIsMain && targetIsMain) return 300;
                            if (sourceIsMain || targetIsMain) return 120;
                            return 70;
                        },
                        edgeElasticity: 100, // 엣지 유연성 감소로 더 안정적인 배치
                        gravity: 0.02, // 중력 감소로 노드들이 덜 몰림
                        numIter: 5000, // 반복 횟수 증가로 더 나은 레이아웃
                        randomize: false,
                        componentSpacing: 200, // 컴포넌트 간격 증가
                        nestingFactor: 1,
                        nodeOverlap: 20 // 노드 겹침 방지 추가
                    },
                    userZoomingEnabled: false,
                    userPanningEnabled: false,
                    boxSelectionEnabled: false,
                    autoungrabify: true
                });
                
                // 노드 클릭 이벤트 (메인 노드만)
                const descriptionPanel = document.getElementById('nodeDescriptionPanel');
                const nodeTitle = document.getElementById('nodeTitle');
                const nodeDescription = document.getElementById('nodeDescription');
                const closeBtn = document.getElementById('closeDescription');
                
                if (!descriptionPanel || !nodeTitle || !nodeDescription) {
                    console.error('Description panel elements not found');
                    cyInstance = null;
                    return;
                }
                
                // 메인 노드 클릭 이벤트 (클래스 기반 셀렉터)
                cyInstance.on('tap', '.main-node', function(evt) {
                    const node = evt.target;
                    const data = node.data();
                    
                    // 모든 노드와 엣지의 하이라이트 제거
                    cyInstance.elements().removeClass('highlighted');
                    
                    // 클릭한 노드와 연결된 엣지 하이라이트
                    node.addClass('highlighted');
                    node.connectedEdges().addClass('highlighted');
                    
                    // 설명 패널 표시
                    nodeTitle.textContent = data.label || 'Unknown';
                    nodeDescription.textContent = data.description || 'No description available';
                    descriptionPanel.classList.add('active');
                });
                
                // 배경 클릭 시 하이라이트 제거
                cyInstance.on('tap', function(evt) {
                    if (evt.target === cyInstance) {
                        cyInstance.elements().removeClass('highlighted');
                        descriptionPanel.classList.remove('active');
                    }
                });
                
                // 닫기 버튼
                if (closeBtn) {
                    closeBtn.addEventListener('click', function() {
                        if (cyInstance) {
                            cyInstance.elements().removeClass('highlighted');
                        }
                        descriptionPanel.classList.remove('active');
                    });
                }
                
                // 빈 공간 호버링 시 작은 노드 밀어내기 효과
                let mousePosition = { x: 0, y: 0 };
                let animationFrame = null;
                const originalPositions = new Map(); // 원래 위치 저장
                
                // 마우스 움직임 추적
                cyInstance.on('mousemove', function(evt) {
                    mousePosition = evt.position; // 항상 업데이트
                    
                    // 애니메이션이 실행 중이 아니면 시작
                    if (!animationFrame) {
                        animationFrame = requestAnimationFrame(repelDecoratorNodes);
                    }
                });
                
                // Decorator 노드들을 마우스로부터 밀어내는 함수
                function repelDecoratorNodes() {
                    const decoratorNodes = cyInstance.nodes('.decorator-node');
                    const repelRadius = 800; // 영향 범위
                    const repelStrength = 30; // 밀어내는 강도
                    let hasMovement = false; // 움직임이 있는지 추적
                    
                    decoratorNodes.forEach(node => {
                        const nodePos = node.position();
                        const nodeId = node.id();
                        
                        // 원래 위치 저장 (처음 한 번만)
                        if (!originalPositions.has(nodeId)) {
                            originalPositions.set(nodeId, { x: nodePos.x, y: nodePos.y });
                        }
                        
                        const originalPos = originalPositions.get(nodeId);
                        
                        // 마우스와 노드 사이의 거리 계산
                        const dx = nodePos.x - mousePosition.x;
                        const dy = nodePos.y - mousePosition.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < repelRadius && distance > 0) {
                            // 마우스로부터 밀어내기
                            const force = (1 - distance / repelRadius) * repelStrength;
                            const angle = Math.atan2(dy, dx);
                            
                            const newX = originalPos.x + Math.cos(angle) * force;
                            const newY = originalPos.y + Math.sin(angle) * force;
                            
                            node.position({ x: newX, y: newY });
                            hasMovement = true;
                        } else {
                            // 원래 위치로 부드럽게 복귀
                            const currentX = nodePos.x;
                            const currentY = nodePos.y;
                            const returnSpeed = 0.15; // 복귀 속도 (0-1)
                            const diffX = originalPos.x - currentX;
                            const diffY = originalPos.y - currentY;
                            
                            // 충분히 원위치에 가까우면 정확히 맞춤
                            if (Math.abs(diffX) < 0.5 && Math.abs(diffY) < 0.5) {
                                node.position({ x: originalPos.x, y: originalPos.y });
                            } else {
                                const newX = currentX + diffX * returnSpeed;
                                const newY = currentY + diffY * returnSpeed;
                                node.position({ x: newX, y: newY });
                                hasMovement = true;
                            }
                        }
                    });
                    
                    // 움직임이 있을 때만 계속 애니메이션
                    if (hasMovement) {
                        animationFrame = requestAnimationFrame(repelDecoratorNodes);
                    } else {
                        animationFrame = null;
                    }
                }
                
                // 마우스가 그래프 영역을 벗어났을 때
                cyContainer.addEventListener('mouseleave', function() {
                    if (animationFrame) {
                        cancelAnimationFrame(animationFrame);
                        animationFrame = null;
                    }
                    
                    // 모든 노드를 원래 위치로 복귀
                    const decoratorNodes = cyInstance.nodes('.decorator-node');
                    decoratorNodes.forEach(node => {
                        const originalPos = originalPositions.get(node.id());
                        if (originalPos) {
                            node.animate({
                                position: { x: originalPos.x, y: originalPos.y }
                            }, {
                                duration: 400,
                                easing: 'ease-out'
                            });
                        }
                    });
                });
                
                console.log('Knowledge Graph initialized successfully with', graphData.nodes.length, 'main nodes');
                
            } catch (error) {
                console.error('Error initializing knowledge graph:', error);
                cyInstance = null;
            }
        }

    </script>
</body>
</html>
