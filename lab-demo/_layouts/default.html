<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="{{ "/assets/css/style.css" | relative_url }}">
    <title>{{ page.title }} | {{ site.title }}</title>
</head>
<body>
    <header class="site-header">
        <div class="header-container">
            <h1 class="site-title"><a href="{{ "/" | relative_url }}">{{ site.title }}</a></h1>
            <nav class="main-nav">
                <ul>
                    <li><a href="#about">About</a></li>
                    <li><a href="#professor">Professor</a></li>
                    <li><a href="#members">Members</a></li>
                    <li><a href="#publications">Publications</a></li>
                    <li><a href="#projects">Projects</a></li>
                    <li><a href="#photos">Photos</a></li>
                    <li><a href="#contacts">Contacts</a></li>
                </ul>
            </nav>
        </div>
    </header>

    <main>
        {{ content }}
    </main>

    <footer class="site-footer">
        <div class="footer-container">
            <p>&copy; {{ site.time | date: "%Y" }} {{ site.title }}. All rights reserved.</p>
            {% if site.github_username %}
            <p>
                <a href="https://github.com/{{ site.github_username }}" target="_blank" rel="noopener">GitHub</a>
            </p>
            {% endif %}
        </div>
    </footer>

    <script>
        // Enhanced smooth scroll with custom easing function
        function easeInOutCubic(t) {
            return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
        }

        let isProgrammaticScroll = false;

        function smoothScrollTo(targetElement, duration = 600) {
            isProgrammaticScroll = true;
            const headerOffset = 80;
            const targetPosition = targetElement.getBoundingClientRect().top + window.pageYOffset - headerOffset;
            const startPosition = window.pageYOffset;
            const distance = targetPosition - startPosition;
            let startTime = null;

            function animation(currentTime) {
                if (startTime === null) startTime = currentTime;
                const timeElapsed = currentTime - startTime;
                const progress = Math.min(timeElapsed / duration, 1);
                const ease = easeInOutCubic(progress);
                
                window.scrollTo(0, startPosition + distance * ease);
                
                if (timeElapsed < duration) {
                    requestAnimationFrame(animation);
                } else {
                    // Scroll completed, allow nav updates after a short delay
                    setTimeout(function() {
                        isProgrammaticScroll = false;
                        updateActiveNav();
                    }, 100);
                }
            }

            requestAnimationFrame(animation);
        }

        // Smooth scroll for navigation links
        document.querySelectorAll('a[href^="#"]').forEach(anchor => {
            anchor.addEventListener('click', function (e) {
                e.preventDefault();
                const targetId = this.getAttribute('href');
                const target = document.querySelector(targetId);
                
                if (target) {
                    // Add active state to clicked link immediately
                    document.querySelectorAll('.main-nav a').forEach(link => {
                        link.classList.remove('active');
                    });
                    this.classList.add('active');
                    
                    // Smooth scroll to target
                    smoothScrollTo(target, 400);
                }
            });
        });

        // Highlight active navigation item on scroll - continuously update, but pause during nav button scroll
        let scrollTimeout = null;
        let scrollAnimationFrame = null;

        function updateActiveNav() {
            // Don't update during programmatic scroll (when nav button is pressed)
            if (isProgrammaticScroll) return;

            const sections = document.querySelectorAll('section[id]');
            const navLinks = document.querySelectorAll('.main-nav a[href^="#"]');
            
            let current = '';
            const scrollPosition = window.pageYOffset;
            const viewportHeight = window.innerHeight;
            
            // Find the section that is most visible in the viewport
            sections.forEach(section => {
                const sectionTop = section.offsetTop;
                const sectionBottom = sectionTop + section.offsetHeight;
                const sectionMiddle = sectionTop + section.offsetHeight / 2;
                
                // Check if section is significantly visible (at least 40% of viewport height)
                const visibleTop = Math.max(scrollPosition + 100, sectionTop);
                const visibleBottom = Math.min(scrollPosition + viewportHeight, sectionBottom);
                const visibleHeight = Math.max(0, visibleBottom - visibleTop);
                const minVisibleHeight = viewportHeight * 0.4;
                
                if (visibleHeight >= minVisibleHeight) {
                    // Prefer section that is more centered
                    const distanceFromCenter = Math.abs((scrollPosition + viewportHeight / 2) - sectionMiddle);
                    if (current === '') {
                        current = section.getAttribute('id');
                    } else {
                        const currentSection = document.querySelector('#' + current);
                        if (currentSection) {
                            const currentMiddle = currentSection.offsetTop + currentSection.offsetHeight / 2;
                            const currentDistance = Math.abs((scrollPosition + viewportHeight / 2) - currentMiddle);
                            if (distanceFromCenter < currentDistance) {
                                current = section.getAttribute('id');
                            }
                        }
                    }
                }
            });

            navLinks.forEach(link => {
                link.classList.remove('active');
                if (link.getAttribute('href') === '#' + current) {
                    link.classList.add('active');
                }
            });
        }

        // Continuous update during user scroll (throttled with requestAnimationFrame)
        function handleScroll() {
            // Cancel any pending timeout
            if (scrollTimeout) {
                clearTimeout(scrollTimeout);
                scrollTimeout = null;
            }

            // Cancel any pending animation frame
            if (scrollAnimationFrame) {
                cancelAnimationFrame(scrollAnimationFrame);
            }

            // Schedule update (only if not programmatically scrolling)
            if (!isProgrammaticScroll) {
                scrollAnimationFrame = requestAnimationFrame(function() {
                    updateActiveNav();
                });
            }
        }

        window.addEventListener('scroll', handleScroll, { passive: true });

        // Update active nav on page load
        updateActiveNav();
    </script>
</body>
</html>
